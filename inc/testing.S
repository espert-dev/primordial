# ===========================================================================
# Testing macros
# ===========================================================================

# Test case entry.
#
# These entries are generated by the test_case macro and reside in
# the custom .test_cases section of the executable.
.struct 0
test_case_entry:
"test_case_entry.fn": .space 8
"test_case_entry.name": .space 8
"test_case_entry.name_size": .space 8
.equiv test_case_entry_size, . - test_case_entry

# Testing state.
.struct 0
testing_state:
"testing_state.suite_failed": .space 8
"testing_state.test_failed": .space 8
"testing_state.spill_0": .space 8
"testing_state.spill_1": .space 8
.equiv testing_state_size, . - testing_state


# ===========================================================================
# Test case macros
# ===========================================================================

# Start a test case definition.
.macro test_case t

# Use a custom ELF section to store information about the test cases that
# we can retrieve from the test suite runner without user intervention.
#
# "a" makes the section read-only, like .rodata.
# "M" means fixed-sized mergeable records (of size 24).
# "R" means retention (prevent garbage collection by the linker).
# "progbits" means the section contains data.
#
# See https://sourceware.org/binutils/docs/as/Section.html
.section .test_cases, "aMR", @progbits, test_case_entry_size
.align 3
.8byte test_\t
.8byte test_\t\()_name
.8byte test_\t\()_name_size

.section .rodata
test_\t\()_name:
.ascii "\t"
.equiv test_\t\()_name_size , . - test_\t\()_name

.section .text
test_\t:
	.cfi_startproc
.endm

# End a test case definition.
.macro end_test
	.cfi_endproc
.endm

# Run a test case. Call from within a test suite.
.macro run_test t
	la a0, test_\t
	la a1, test_\t\()_name
	li a2, test_\t\()_name_size
	call run_test
.endm


# ===========================================================================
# Assertions
# ===========================================================================

# Avoid introducing register aliases to prevent pollution on user code.
#
# Still, there's the risk of user code passing them as expected or equal.
# To reduce the probability of that happening, we use the last ones.

.macro expect_eq expected, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	sub t5, \expected, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_ne forbidden, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	sub t5, \forbidden, \actual
	seqz t5, t5
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_eqi expected, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	addi t5, \actual, -\expected
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nei forbidden, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	addi t5, \actual, -\forbidden
	seqz t5, t5
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_z actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	or t6, t6, \actual

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nz actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	seqz t5, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.section .text
