# ===========================================================================
# Testing macros
# ===========================================================================

#include <compat.S>


# Test case entry.
#
# These entries are generated by the test_case macro and reside in
# the custom .test_cases section of the executable.
.struct 0
test_case_entry:
"test_case_entry.fn": .space XLEN_BYTES
"test_case_entry.name_size": .space XLEN_BYTES
"test_case_entry.name_data": .space XLEN_BYTES
.equiv test_case_entry_size, . - test_case_entry

# Testing state.
.struct 0
testing_state:
"testing_state.suite_failed": .space XLEN_BYTES
"testing_state.test_failed": .space XLEN_BYTES
"testing_state.spill_0": .space XLEN_BYTES
"testing_state.spill_1": .space XLEN_BYTES
.equiv testing_state_size, . - testing_state


# ===========================================================================
# Test case macros
# ===========================================================================

# Start a test case definition.
.macro test_case t

# Use a custom ELF section to store information about the test cases that
# we can retrieve from the test suite runner without user intervention.
#
# "a" makes the section read-only, like .rodata.
# "M" means fixed-sized mergeable records (of size 24).
# "R" means retention (prevent garbage collection by the linker).
# "progbits" means the section contains data.
#
# See https://sourceware.org/binutils/docs/as/Section.html
.section .test_cases, "aMR", @progbits, test_case_entry_size
Xalign
Xbyte "test_\t"
Xbyte "test_\t\()_name_size"
Xbyte "test_\t\()_name_data"

.section .rodata
test_\t\()_name_data:
.ascii "\t"
.equiv "test_\t\()_name_size" , . - "test_\t\()_name_data"

.section .text
"test_\t":
	.cfi_startproc
.endm

# End a test case definition.
.macro end_test
	.cfi_endproc
.endm


# ===========================================================================
# Assertions
# ===========================================================================

# Avoid introducing register aliases to prevent pollution on user code.
#
# Still, there's the risk of user code passing them as expected or equal.
# To reduce the probability of that happening, we use the last ones.

.macro expect_eq expected, actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	sub t5, \expected, \actual
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_ne forbidden, actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	sub t5, \forbidden, \actual
	seqz t5, t5
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_positive actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	slti t5, \actual, 1
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_negative actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	# Check the MSB.
#if XLEN == 32
	#define MSB 31
#elif XLEN == 64
	#define MSB 63
#else
	#error invalid or undefined XLEN.
#endif

	not t5, \actual
        srli t5, t5, MSB
        or t6, t6, t5
#undef MSB

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_eqa expected, actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	la t5, "\expected"
	sub t5, t5, \actual
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_eqi expected, actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	li t5, \expected
	sub t5, t5, \actual
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nei forbidden, actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	li t5, \forbidden
	sub t5, t5, \actual
	seqz t5, t5
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_z actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	or t6, t6, \actual

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nz actual
	sx t6, "testing_state.spill_0"(tp)
	sx t5, "testing_state.spill_1"(tp)
	lx t6, "testing_state.test_failed"(tp)

	seqz t5, \actual
	or t6, t6, t5

	sx t6, "testing_state.test_failed"(tp)
	lx t6, "testing_state.spill_0"(tp)
	lx t5, "testing_state.spill_1"(tp)
.endm

.section .text
