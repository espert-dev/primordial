# ===========================================================================
# Testing macros
# ===========================================================================

# Test case entry.
#
# These entries are generated by the test_case macro and reside in
# the custom .test_cases section of the executable.
.struct 0
test_case_entry:
"test_case_entry.fn": .space 8
"test_case_entry.name_size": .space 8
"test_case_entry.name_data": .space 8
.equiv test_case_entry_size, . - test_case_entry

# Testing state.
.struct 0
testing_state:
"testing_state.suite_failed": .space 8
"testing_state.test_failed": .space 8
"testing_state.spill_0": .space 8
"testing_state.spill_1": .space 8
.equiv testing_state_size, . - testing_state


# ===========================================================================
# Test case macros
# ===========================================================================

# Start a test case definition.
.macro test_case t

# Use a custom ELF section to store information about the test cases that
# we can retrieve from the test suite runner without user intervention.
#
# "a" makes the section read-only, like .rodata.
# "M" means fixed-sized mergeable records (of size 24).
# "R" means retention (prevent garbage collection by the linker).
# "progbits" means the section contains data.
#
# See https://sourceware.org/binutils/docs/as/Section.html
.section .test_cases, "aMR", @progbits, test_case_entry_size
.p2align 3
.8byte "test_\t"
.8byte "test_\t\()_name_size"
.8byte "test_\t\()_name_data"

.section .rodata
test_\t\()_name_data:
.ascii "\t"
.equiv "test_\t\()_name_size" , . - "test_\t\()_name_data"

.section .text
"test_\t":
	.cfi_startproc
.endm

# End a test case definition.
.macro end_test
	.cfi_endproc
.endm


# ===========================================================================
# Assertions
# ===========================================================================

# Avoid introducing register aliases to prevent pollution on user code.
#
# Still, there's the risk of user code passing them as expected or equal.
# To reduce the probability of that happening, we use the last ones.

.macro expect_eq expected, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	sub t5, \expected, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_ne forbidden, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	sub t5, \forbidden, \actual
	seqz t5, t5
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_positive expected
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	slti t5, \expected, 1
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_negative expected
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	# Check the MSB.
	not t5, \expected
	srli t5, t5, 63
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_eqa expected, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	la t5, "\expected"
	sub t5, t5, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_eqi expected, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	li t5, \expected
	sub t5, t5, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nei forbidden, actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	li t5, \forbidden
	sub t5, t5, \actual
	seqz t5, t5
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_z actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	or t6, t6, \actual

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.macro expect_nz actual
	sd t6, "testing_state.spill_0"(tp)
	sd t5, "testing_state.spill_1"(tp)
	ld t6, "testing_state.test_failed"(tp)

	seqz t5, \actual
	or t6, t6, t5

	sd t6, "testing_state.test_failed"(tp)
	ld t6, "testing_state.spill_0"(tp)
	ld t5, "testing_state.spill_1"(tp)
.endm

.section .text
